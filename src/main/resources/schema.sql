-- TABLES DDL
--CREATE TABLE PRODUCTS (
--     ID NUMBER,
--     NAME VARCHAR2(50),
--     INVENTORY_COUNT NUMBER(10),
--     UNIT_PRICE NUMBER(*,2),
--     PRIMARY KEY(ID)
--);
--
--CREATE TABLE ORDERS (
--     ID NUMBER,
--     CUSTOMER_NAME VARCHAR2(50),
--     QUANTITY NUMBER(10),
--     ORDER_PRICE NUMBER(*,2),
--     TSTMP TIMESTAMP,
--     PRODUCT_ID NUMBER,
--     PRIMARY KEY(ID)
--);
--
--CREATE TABLE AUDIT_PRODUCTS (
--     ID NUMBER,
--     NAME VARCHAR2(50),
--     UNIT_PRICE NUMBER(*,2),
--     INVENTORY_COUNT NUMBER(10),
--     INVENTORY_CHANGE NUMBER(10),
--     REVISION_TYPE NCHAR(6),
--     REVISION_TSTMP TIMESTAMP,
--     PRODUCT_ID NUMBER,
--     PRIMARY KEY(ID)
--);
--
-- SEQUENCES DDL
--CREATE SEQUENCE SEQ_PRODUCTS_ID START WITH 1 INCREMENT BY 1;
--
--CREATE SEQUENCE SEQ_ORDERS_ID START WITH 1 INCREMENT BY 1;
--
--CREATE SEQUENCE SEQ_AUDIT_PRODUCTS_ID START WITH 1 INCREMENT BY 1;
--
-- TRIGGER FOR ENSURING ORDERS CAN ONLY BE CREATED OR MANIPULATED DURING BUSINESS HOURS
--CREATE OR REPLACE TRIGGER BUSINESS_HOURS_TRIGGER
--  BEFORE 
--  INSERT OR UPDATE OR DELETE
--  ON ORDERS
--DECLARE
--  DAY_OF_WEEK CHAR;
--  HOUR_OF_DAY NUMBER(2);
--  OUTSIDE_OF_HOURS EXCEPTION;
--  PRAGMA EXCEPTION_INIT(OUTSIDE_OF_HOURS, -20001);
--BEGIN
--  SELECT TO_CHAR(SYSDATE, 'D')
--  INTO DAY_OF_WEEK
--  FROM DUAL;
--  
--  SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP)
--  INTO HOUR_OF_DAY
--  FROM DUAL;
--
--  IF DAY_OF_WEEK = '1' OR DAY_OF_WEEK = '7' THEN
--    RAISE_APPLICATION_ERROR(-20001, 'Cannot place order on weekends');
--  END IF;
--    
--  IF HOUR_OF_DAY < 12 OR HOUR_OF_DAY > 21 THEN
--    RAISE_APPLICATION_ERROR(-20001, 'Cannot place order outside of business hours');
--  END IF;
--END;
--
-- TRIGGER FOR INPUTING TOTAL ORDER PRICE AND ITS TIMESTAMP
--CREATE OR REPLACE TRIGGER ORDER_PRICE_TRIGGER 
--    BEFORE 
--    INSERT OR UPDATE
--    ON ORDERS
--    FOR EACH ROW
--DECLARE
--    PRICE NUMBER(20,2);
--BEGIN
--    SELECT UNIT_PRICE
--    INTO PRICE
--    FROM PRODUCTS
--    WHERE PRODUCTS.ID = :NEW.PRODUCT_ID;
--    
--    :NEW.ORDER_PRICE := :NEW.QUANTITY * PRICE;
--    
--    :NEW.TSTMP := CURRENT_TIMESTAMP;
--END;
--
-- TRIGGER FOR ENUSRING THAT THERE IS ENOUGH OF THE PRODUCT IN STOCK BEFORE PLACING AN ORDER
--CREATE OR REPLACE TRIGGER CHECK_INVENTORY_TRIGGER
--    BEFORE
--    INSERT
--    ON ORDERS
--    FOR EACH ROW
--DECLARE
--    STOCK NUMBER;
--    NOT_ENOUGH_STOCK EXCEPTION;
--    PRAGMA EXCEPTION_INIT(NOT_ENOUGH_STOCK, -20002);
--BEGIN
--    SELECT INVENTORY_COUNT
--    INTO STOCK
--    FROM PRODUCTS
--    WHERE PRODUCTS.ID = :NEW.PRODUCT_ID;
--    
--    IF STOCK < :NEW.QUANTITY THEN
--        RAISE_APPLICATION_ERROR(-20002, 'Not enough product in stock');
--    END IF;
--
--    UPDATE PRODUCTS SET INVENTORY_COUNT = (INVENTORY_COUNT - :NEW.QUANTITY)
--    WHERE ID = :NEW.PRODUCT_ID;
--END;
--
-- TRIGGER FOR ENSURING THERE IS ENOUGH OF THE PRODUCT IN STOCK BEFORE UPDATING AN ORDER; 
--CREATE OR REPLACE TRIGGER UPDATE_ORDER_TRIGGER
--  BEFORE
--  UPDATE
--  ON ORDERS
--  FOR EACH ROW
--DECLARE
--  STOCK NUMBER;
--  NOT_ENOUGH_STOCK EXCEPTION;
--  PRAGMA EXCEPTION_INIT(NOT_ENOUGH_STOCK, -20002);
--BEGIN
--  SELECT INVENTORY_COUNT
--  INTO STOCK
--  FROM PRODUCTS
--  WHERE PRODUCTS.ID = :NEW.PRODUCT_ID;
--  
--  IF STOCK < :NEW.QUANTITY - :OLD.QUANTITY THEN
--    RAISE_APPLICATION_ERROR(-20002, 'Not enough product in stock');
--  END IF;
--  
--  UPDATE PRODUCTS SET INVENTORY_COUNT = INVENTORY_COUNT - (:NEW.QUANTITY - :OLD.QUANTITY)
--  WHERE ID = :OLD.PRODUCT_ID;
--END;
--
-- TRIGGER FOR REPLINSHING INVENTORY STOCK AFTE A DELETED ORDER
--CREATE OR REPLACE TRIGGER DELETE_ORDER_TRIGGER
--  AFTER
--  DELETE
--  ON ORDERS
--  FOR EACH ROW
--BEGIN
--  UPDATE PRODUCTS SET INVENTORY_COUNT = INVENTORY_COUNT + :OLD.QUANTITY
--  WHERE ID = :OLD.PRODUCT_ID;
--END;
--
-- TRIGGER FOR AUDTING PRODUCTS
--CREATE OR REPLACE TRIGGER PRODUCTS_AUDIT_TRIGGER
--    AFTER
--    INSERT OR UPDATE OR DELETE
--    ON PRODUCTS
--    FOR EACH ROW
--BEGIN
--    CASE
--        WHEN INSERTING THEN
--            INSERT INTO AUDIT_PRODUCTS VALUES (SEQ_AUDIT_PRODUCTS_ID.NEXTVAL,
--                :NEW.NAME, :NEW.UNIT_PRICE, :NEW.INVENTORY_COUNT,
--                :NEW.INVENTORY_COUNT, 'INSERT', CURRENT_TIMESTAMP, :NEW.ID);
--        WHEN UPDATING THEN
--            INSERT INTO AUDIT_PRODUCTS VALUES (SEQ_AUDIT_PRODUCTS_ID.NEXTVAL,
--                :NEW.NAME, :NEW.UNIT_PRICE, :NEW.INVENTORY_COUNT,
--                :NEW.INVENTORY_COUNT - :OLD.INVENTORY_COUNT), 'UDPATE', 
--                CURRENT_TIMESTAMP, :NEW.ID);
--        WHEN DELETING THEN
--            INSERT INTO AUDIT_PRODUCTS VALUES (SEQ_AUDIT_PRODUCTS_ID.NEXTVAL,
--                :OLD.NAME, :OLD.UNIT_PRICE, :OLD.INVENTORY_COUNT, 0,
--                'DELETE', CURRENT_TIMESTAMP, :OLD.ID);
--    END CASE;
--END;
--
-- TRIGGER FOR AUDTING PRODUCTS
--CREATE OR REPLACE TRIGGER PRODUCTS_AUDIT_TRIGGER
--    AFTER
--    INSERT OR UPDATE OR DELETE
--    ON PRODUCTS
--    FOR EACH ROW
--BEGIN
--    CASE
--        WHEN INSERTING THEN
--            INSERT INTO AUDIT_PRODUCTS VALUES (SEQ_AUDIT_PRODUCTS_ID.NEXTVAL,
--                :NEW.NAME, :NEW.UNIT_PRICE, :NEW.INVENTORY_COUNT,
--                :NEW.INVENTORY_COUNT, 'INSERT', CURRENT_TIMESTAMP, :NEW.ID);
--        WHEN UPDATING THEN
--            INSERT INTO AUDIT_PRODUCTS VALUES (SEQ_AUDIT_PRODUCTS_ID.NEXTVAL,
--                :NEW.NAME, :NEW.UNIT_PRICE, :NEW.INVENTORY_COUNT,
--                :NEW.INVENTORY_COUNT - :OLD.INVENTORY_COUNT, 'UDPATE', 
--                CURRENT_TIMESTAMP, :NEW.ID);
--        WHEN DELETING THEN
--            INSERT INTO AUDIT_PRODUCTS VALUES (SEQ_AUDIT_PRODUCTS_ID.NEXTVAL,
--                :OLD.NAME, :OLD.UNIT_PRICE, :OLD.INVENTORY_COUNT, 0, 'DELETE', 
--                CURRENT_TIMESTAMP, :OLD.ID);
--    END CASE;
--END;
--  