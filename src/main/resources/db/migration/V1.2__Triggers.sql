-- TRIGGER FOR ENSURING ORDERS CAN ONLY BE CREATED OR MANIPULATED DURING BUSINESS HOURS
CREATE OR REPLACE TRIGGER BUSINESS_HOURS_TRIGGER
  BEFORE 
  INSERT OR UPDATE OR DELETE
  ON ORDERS
DECLARE
  DAY_OF_WEEK CHAR;
  HOUR_OF_DAY NUMBER(2);
  OUTSIDE_OF_HOURS EXCEPTION;
  PRAGMA EXCEPTION_INIT(OUTSIDE_OF_HOURS, -20001);
BEGIN
  SELECT TO_CHAR(SYSDATE, 'D')
  INTO DAY_OF_WEEK
  FROM DUAL;
  
  SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP)
  INTO HOUR_OF_DAY
  FROM DUAL;

  IF DAY_OF_WEEK = '1' OR DAY_OF_WEEK = '7' THEN
    RAISE_APPLICATION_ERROR(-20001, 'Cannot place order on weekends');
  END IF;
    
  IF HOUR_OF_DAY < 12 OR HOUR_OF_DAY > 21 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Cannot place order outside of business hours');
  END IF;
END;
/

-- TRIGGER FOR INPUTING TOTAL ORDER PRICE AND ITS TIMESTAMP
CREATE OR REPLACE TRIGGER ORDER_PRICE_TRIGGER 
    BEFORE 
    INSERT OR UPDATE
    ON ORDERS
    FOR EACH ROW
DECLARE
    PRICE NUMBER(20,2);
BEGIN
    SELECT UNIT_PRICE
    INTO PRICE
    FROM PRODUCTS
    WHERE PRODUCTS.ID = :NEW.PRODUCT_ID;
    
    :NEW.ORDER_PRICE := :NEW.QUANTITY * PRICE;
    
    :NEW.TSTMP := CURRENT_TIMESTAMP;
END;
/

-- TRIGGER FOR ENUSRING THAT THERE IS ENOUGH OF THE PRODUCT IN STOCK BEFORE PLACING AN ORDER
CREATE OR REPLACE TRIGGER CHECK_INVENTORY_TRIGGER
    BEFORE
    INSERT
    ON ORDERS
    FOR EACH ROW
DECLARE
    STOCK NUMBER;
    NOT_ENOUGH_STOCK EXCEPTION;
    PRAGMA EXCEPTION_INIT(NOT_ENOUGH_STOCK, -20002);
BEGIN
    SELECT INVENTORY_COUNT
    INTO STOCK
    FROM PRODUCTS
    WHERE PRODUCTS.ID = :NEW.PRODUCT_ID;
    
    IF STOCK < :NEW.QUANTITY THEN
        RAISE_APPLICATION_ERROR(-20002, 'Not enough product in stock');
    END IF;

    UPDATE PRODUCTS SET INVENTORY_COUNT = (INVENTORY_COUNT - :NEW.QUANTITY)
    WHERE ID = :NEW.PRODUCT_ID;
END;
/

-- TRIGGER FOR ENSURING THERE IS ENOUGH OF THE PRODUCT IN STOCK BEFORE UPDATING AN ORDER; 
CREATE OR REPLACE TRIGGER UPDATE_ORDER_TRIGGER
  BEFORE
  UPDATE
  ON ORDERS
  FOR EACH ROW
DECLARE
  STOCK NUMBER;
  NOT_ENOUGH_STOCK EXCEPTION;
  PRAGMA EXCEPTION_INIT(NOT_ENOUGH_STOCK, -20002);
BEGIN
  SELECT INVENTORY_COUNT
  INTO STOCK
  FROM PRODUCTS
  WHERE PRODUCTS.ID = :NEW.PRODUCT_ID;
  
  IF STOCK < :NEW.QUANTITY - :OLD.QUANTITY THEN
    RAISE_APPLICATION_ERROR(-20002, 'Not enough product in stock');
  END IF;
  
  UPDATE PRODUCTS SET INVENTORY_COUNT = INVENTORY_COUNT - (:NEW.QUANTITY - :OLD.QUANTITY)
  WHERE ID = :OLD.PRODUCT_ID;
END;
/

-- TRIGGER FOR REPLINSHING INVENTORY STOCK AFTER DELETING AN ORDER
CREATE OR REPLACE TRIGGER DELETE_ORDER_TRIGGER
  AFTER
  DELETE
  ON ORDERS
  FOR EACH ROW
BEGIN
  UPDATE PRODUCTS SET INVENTORY_COUNT = INVENTORY_COUNT + :OLD.QUANTITY
  WHERE ID = :OLD.PRODUCT_ID;
END;
/

-- TRIGGER FOR AUDTING PRODUCTS
CREATE OR REPLACE TRIGGER PRODUCTS_AUDIT_TRIGGER
    AFTER
    INSERT OR UPDATE OR DELETE
    ON PRODUCTS
    FOR EACH ROW
BEGIN
    CASE
        WHEN INSERTING THEN
            INSERT INTO AUDIT_PRODUCTS VALUES (SEQ_AUDIT_PRODUCTS_ID.NEXTVAL,
                :NEW.NAME, :NEW.UNIT_PRICE, :NEW.INVENTORY_COUNT,
                :NEW.INVENTORY_COUNT, 'INSERT', CURRENT_TIMESTAMP, :NEW.ID);
        WHEN UPDATING THEN
            INSERT INTO AUDIT_PRODUCTS VALUES (SEQ_AUDIT_PRODUCTS_ID.NEXTVAL,
                :NEW.NAME, :NEW.UNIT_PRICE, :NEW.INVENTORY_COUNT,
                :NEW.INVENTORY_COUNT - :OLD.INVENTORY_COUNT, 'UPDATE', 
                CURRENT_TIMESTAMP, :NEW.ID);
        WHEN DELETING THEN
            INSERT INTO AUDIT_PRODUCTS VALUES (SEQ_AUDIT_PRODUCTS_ID.NEXTVAL,
                :OLD.NAME, :OLD.UNIT_PRICE, :OLD.INVENTORY_COUNT, 0, 'DELETE', 
                CURRENT_TIMESTAMP, :OLD.ID);
    END CASE;
END;
/
